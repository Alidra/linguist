require open tests.OK.Set tests.OK.Prop tests.OK.FOL tests.OK.Eq
  tests.OK.Nat tests.OK.Bool;

(a:Set) inductive ğ•ƒ:TYPE â‰”
| â–¡ : ğ•ƒ a // \Box
| â¸¬ : Ï„ a â†’ ğ•ƒ a â†’ ğ•ƒ a; // ::

notation â¸¬ infix right 20;

// set code for ğ•ƒ

constant symbol list : Set â†’ Set;

rule Ï„ (list $a) â†ª ğ•ƒ $a;

// isâ–¡

symbol isâ–¡ [a]: ğ•ƒ a â†’ ğ”¹;

rule isâ–¡ â–¡ â†ª true
with isâ–¡ (_ â¸¬ _) â†ª false;

// non confusion of constructors

opaque symbol â¸¬â‰ â–¡ [a] [x:Ï„ a] [l] : Ï€ (x â¸¬ l â‰  â–¡) â‰”
begin
  assume a x l h; refine ind_eq h (Î» l, istrue(isâ–¡ l)) âŠ¤áµ¢
end;

opaque symbol â–¡â‰ â¸¬ [a] [x:Ï„ a] [l] : Ï€ (â–¡ â‰  x â¸¬ l) â‰”
begin
  assume a x l h; apply @â¸¬â‰ â–¡ a x l; symmetry; apply h
end;

// head

symbol head [a] : Ï„ a â†’ ğ•ƒ a â†’ Ï„ a;

rule head $x â–¡ â†ª $x
with head _ ($x â¸¬ _) â†ª $x;

// tail

symbol behead [a] : ğ•ƒ a â†’ ğ•ƒ a;

rule behead â–¡ â†ª â–¡
with behead (_ â¸¬ $l) â†ª $l;

// injectivity of constructors

opaque symbol â¸¬_inj [a] [x:Ï„ a] [l y m] : Ï€(x â¸¬ l = y â¸¬ m) â†’ Ï€(x = y âˆ§ l = m) â‰”
begin
  assume a x l y m e; apply âˆ§áµ¢ { refine feq (head x) e } { refine feq behead e }
end;

// boolean equality on lists

symbol eql [a] : (Ï„ a â†’ Ï„ a â†’ ğ”¹) â†’ ğ•ƒ a â†’ ğ•ƒ a â†’ ğ”¹;

rule eql _ â–¡ â–¡ â†ª true
with eql _ (_ â¸¬ _) â–¡ â†ª false
with eql _ â–¡ (_ â¸¬ _) â†ª false
with eql $beq ($x â¸¬ $l) ($y â¸¬ $m) â†ª ($beq $x $y) and (eql $beq $l $m);

opaque symbol eql_correct a (beq:Ï„ a â†’ Ï„ a â†’ ğ”¹) :
  Ï€(`âˆ€ x, `âˆ€ y, beq x y â‡’ x = y) â†’ Ï€(`âˆ€ l, `âˆ€ m, eql beq l m â‡’ l = m) â‰”
begin
  assume a beq beq_correct; induction
  { induction
    { reflexivity }
    { simplify; assume y m i c; refine âŠ¥â‚‘ c }
  }
  { assume x l h; induction
    { simplify; assume c; refine âŠ¥â‚‘ c; }
    { simplify; assume y m i c;
      apply feq2 (â¸¬) _ _
      { apply beq_correct; apply @andâ‚‘â‚ _ (eql beq l m) c }
      { apply h; refine @andâ‚‘â‚‚ (beq x y) _ c
      } 
    }
  }
end;

opaque symbol eql_complete a (beq : Ï„ a â†’ Ï„ a â†’ ğ”¹) :
  Ï€(`âˆ€ x, `âˆ€ y, x = y â‡’ beq x y) â†’ Ï€(`âˆ€ l, `âˆ€ m, l = m â‡’ eql beq l m) â‰”
begin
  assume a beq beq_complete; induction
  { assume m i; rewrite left i; apply âŠ¤áµ¢; }
  { assume x l h; induction
    { assume j; apply â¸¬â‰ â–¡ j; }
    { assume y m i j; simplify;
      have j': Ï€(x = y âˆ§ l = m) { apply â¸¬_inj j };
      apply @istrue_and (beq x y) (eql beq l m); apply âˆ§áµ¢
      { apply beq_complete x y; apply âˆ§â‚‘â‚ j' }
      { apply h m; apply âˆ§â‚‘â‚‚ j' }
    }
  }
end;

// size

symbol size [a] : ğ•ƒ a â†’ â„•;

rule size â–¡ â†ª 0
with size (_ â¸¬ $l) â†ª size $l +1;

opaque symbol size0nil [a] (l:ğ•ƒ a) : Ï€ (size l = 0) â†’ Ï€ (l = â–¡) â‰”
begin
  assume a; induction
  { reflexivity; }
  { assume e l h i; apply âŠ¥â‚‘; apply sâ‰ 0 i; }
end;

symbol nilp [a] l â‰” is0 (@size a l);

opaque symbol size_behead [a] (l:ğ•ƒ a) : Ï€ (size (behead l) = size l âˆ¸1) â‰”
begin
  assume a; induction
  { reflexivity; }
  { assume e l h; reflexivity; }
end;

// concatenation

symbol ++ [a] : ğ•ƒ a â†’ ğ•ƒ a â†’ ğ•ƒ a; notation ++ infix right 30; // \cdot

assert x y z âŠ¢ x ++ y ++ z â‰¡ x ++ (y ++ z);
assert x l m âŠ¢ x â¸¬ l ++ m â‰¡ x â¸¬ (l ++ m);

rule â–¡ ++ $m â†ª $m
with ($x â¸¬ $l) ++ $m â†ª $x â¸¬ ($l ++ $m);

opaque symbol cat0s [a] (l:ğ•ƒ a) : Ï€ (â–¡ ++ l = l) â‰”
begin
  reflexivity;
end;

opaque symbol cat1s [a] (x:Ï„ a) l : Ï€ ((x â¸¬ â–¡) ++ l = (x â¸¬ l)) â‰”
begin
  reflexivity;
end;

opaque symbol cat_cons [a] (x:Ï„ a) l1 l2 : Ï€ ((x â¸¬ l1) ++ l2 = x â¸¬ (l1 ++ l2)) â‰”
begin
  reflexivity;
end;

// nseq

symbol nseq [a] : â„• â†’ Ï„ a â†’ ğ•ƒ a;

rule nseq 0 _ â†ª â–¡
with nseq ($n +1) $x â†ª $x â¸¬ (nseq $n $x);

// ncons

symbol ncons [a] : â„• â†’ Ï„ a â†’ ğ•ƒ a â†’ ğ•ƒ a;

rule ncons 0 _ $l â†ª $l
with ncons ($n +1) $x $l â†ª $x â¸¬ ncons $n $x $l;

opaque symbol size_ncons [a] n (x:Ï„ a) l : Ï€ (size (ncons n x l) = n + size l) â‰”
begin
  assume a; induction
  { reflexivity; }
  { assume n h x l; simplify; apply feq (+1) (h x l); }
end;

opaque symbol size_nseq [a] n (x:Ï„ a) : Ï€ (size (nseq n x) = n) â‰”
begin
  assume a; induction
  { reflexivity; }
  { assume n h x; simplify; apply feq (+1) (h x); }
end;

opaque symbol cat_nseq [a] n (x:Ï„ a) l : Ï€ (nseq n x ++ l = ncons n x l) â‰”
begin
  assume a; induction
  { reflexivity; }
  { assume n h x l; simplify; rewrite h x l; reflexivity; }
end;

opaque symbol nseqD [a] n1 n2 (x:Ï„ a) :
  Ï€ (nseq (n1 + n2) x = nseq n1 x ++ nseq n2 x) â‰”
begin
  assume a; induction
  { reflexivity; }
  { assume n1 h n2 x; simplify; rewrite h n2; reflexivity; }
end;

opaque symbol cats0 [a] (l:ğ•ƒ a) : Ï€(l ++ â–¡ = l) â‰”
begin
  assume a;
  induction
    // case l = â–¡
    { reflexivity; }
    // case l = x â¸¬ l'
    { assume x l' h; simplify; rewrite h; reflexivity; }
end;

rule $m ++ â–¡ â†ª $m;

opaque symbol size_cat [a] (l m : ğ•ƒ a) : Ï€(size (l ++ m) = size l + size m) â‰”
begin
  assume a;
  induction
    // case l = â–¡
    { reflexivity; }
    // case l = xâ¸¬l'
    { assume x l' h m; simplify; rewrite h; reflexivity; }
end;

rule size ($l ++ $m) â†ª size $l + size $m;

opaque symbol catA  [a] (l m n : ğ•ƒ a) : Ï€((l ++ m) ++ n = l ++ (m ++ n)) â‰”
begin
  assume a;
  induction
    // case l = â–¡
    { reflexivity; }
    // case l = xâ¸¬l'
    { assume x l' h m n; simplify; rewrite h; reflexivity; }
end;

rule ($l ++ $m) ++ $n â†ª $l ++ ($m ++ $n);

opaque symbol cat_nilp [a] (l1 l2 : ğ•ƒ a) :
  Ï€ (nilp (l1 ++ l2) = (nilp l1 and nilp l2)) â‰”
begin
  assume a; induction
  { reflexivity; }
  { assume e l h l2; simplify; reflexivity; }
end;

// list reversal

symbol rev [a] : ğ•ƒ a â†’ ğ•ƒ a;

rule rev â–¡ â†ª â–¡
with rev ($x â¸¬ $l) â†ª rev $l ++ ($x â¸¬ â–¡);

opaque symbol rev_concat [a] (l m : ğ•ƒ a) : Ï€(rev (l ++ m) = rev m ++ rev l) â‰”
begin
  assume a;
  induction
    // case l = â–¡
    { simplify; reflexivity; }
    // case l = â¸¬
    { assume x l h m; simplify; rewrite h; reflexivity; }
end;

rule rev ($l ++ $m) â†ª rev $m ++ rev $l;

opaque symbol rev_idem [a] (l :ğ•ƒ a) : Ï€(rev (rev l) = l) â‰”
begin
  assume a; induction
  { reflexivity }
  { assume x l h; simplify; rewrite h; reflexivity }
end;

opaque symbol size_rev [a] (l : ğ•ƒ a) : Ï€(size (rev l) = size l) â‰”
begin
  assume a;
  induction
    // case l = â–¡
    { simplify; reflexivity; }
    // case l = â¸¬
    { assume x l h; simplify; rewrite h; reflexivity; }
end;

// rcons

symbol rcons [a] : ğ•ƒ a â†’ Ï„ a â†’ ğ•ƒ a;

rule rcons â–¡ $x â†ª $x â¸¬ â–¡
with rcons ($e â¸¬ $l) $x â†ª $e â¸¬ (rcons $l $x);

opaque symbol cats1 [a] (l:ğ•ƒ a) (z:Ï„ a) : Ï€ (l ++ (z â¸¬ â–¡) = rcons l z) â‰”
begin
  assume a; induction
  { reflexivity; }
  { assume e l h z; simplify; rewrite h z; reflexivity; }
end;

opaque symbol rcons_cons [a] (x:Ï„ a) (s:ğ•ƒ a) (z:Ï„ a) :
  Ï€ (rcons (x â¸¬ s) z = x â¸¬ rcons s z) â‰”
begin
  reflexivity;
end;

// Arr

symbol Arr : â„• â†’ Set â†’ Set â†’ TYPE;

rule Arr 0 _ $b â†ª Ï„ $b
with Arr ($n +1) $a $b â†ª Ï„ $a â†’ Arr $n $a $b;

// seqn

symbol seqn_acc [a] n : ğ•ƒ a â†’ Arr n a (list a);

rule seqn_acc 0 $l â†ª rev $l
with seqn_acc ($n +1) $l $x â†ª seqn_acc $n ($x â¸¬ $l);

symbol seqn [a] n â‰” @seqn_acc a n â–¡;

assert a (x y : Ï„ a) âŠ¢ seqn 2 x y â‰¡ x â¸¬ y â¸¬ â–¡;

// iota

symbol iota : â„• â†’ â„• â†’ ğ•ƒ nat;
rule iota _ 0 â†ª â–¡
with iota $n ($k +1) â†ª $n â¸¬ iota ($n +1) $k;

assert âŠ¢ iota 1 2 â‰¡ 1 â¸¬ 2 â¸¬ â–¡;

// indexes

symbol indexes [a] : ğ•ƒ a â†’ ğ•ƒ nat;

rule indexes $l â†ª iota 0 (size $l);

assert x âŠ¢ indexes (x â¸¬ x â¸¬ x  â¸¬ x â¸¬ â–¡) â‰¡ 0 â¸¬ 1 â¸¬ 2 â¸¬ 3 â¸¬ â–¡;

// last

symbol last [a] : Ï„ a â†’ ğ•ƒ a â†’ Ï„ a;

rule last $x â–¡ â†ª $x
with last _ ($e â¸¬ $l) â†ª last $e $l;

assert âŠ¢ last 4 (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡) â‰¡ 1;
assert âŠ¢ last 4 â–¡ â‰¡ 4;

// belast

symbol belast [a] : Ï„ a â†’ ğ•ƒ a â†’ ğ•ƒ a;

rule belast _ â–¡ â†ª â–¡
with belast $x ($e â¸¬ $l) â†ª $x â¸¬ belast $e $l;

assert âŠ¢ belast 4 (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡) â‰¡ 4 â¸¬ 3 â¸¬ 2 â¸¬ â–¡;

// nth

symbol nth [a] : Ï„ a â†’ ğ•ƒ a â†’ â„• â†’ Ï„ a;

rule nth $x â–¡ _ â†ª $x
with nth _ ($e â¸¬ _) 0 â†ª $e
with nth $x (_ â¸¬ $l) ($n +1) â†ª nth $x $l $n;

assert âŠ¢ nth 4 (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡) 0 â‰¡ 3;
assert âŠ¢ nth 4 (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡) 2 â‰¡ 1;
assert âŠ¢ nth 4 (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡) 3 â‰¡ 4;
assert âŠ¢ nth 4 (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡) 42 â‰¡ 4;

// set_nth

symbol set_nth [a] : Ï„ a â†’ ğ•ƒ a â†’ â„• â†’ Ï„ a â†’ ğ•ƒ a;

rule set_nth _ â–¡ 0 $y â†ª $y â¸¬ â–¡
with set_nth _ (_ â¸¬ $l) 0 $y â†ª $y â¸¬ $l
with set_nth $x â–¡ ($i +1) $y â†ª $x â¸¬ set_nth $x â–¡ $i $y
with set_nth $x ($e â¸¬ $l) ($i +1) $y â†ª $e â¸¬ set_nth $x $l $i $y;

assert âŠ¢ set_nth 42 (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡) 1 6 â‰¡ 3 â¸¬ 6 â¸¬ 1 â¸¬ â–¡;
assert âŠ¢ set_nth 42 (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡) 2 6 â‰¡ 3 â¸¬ 2 â¸¬ 6 â¸¬ â–¡;
assert âŠ¢ set_nth 42 (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡) 5 6 â‰¡ 3 â¸¬ 2 â¸¬ 1 â¸¬ 42 â¸¬ 42 â¸¬ 6 â¸¬ â–¡;

// incr_nth

symbol incr_nth : ğ•ƒ nat â†’ Ï„ nat â†’ ğ•ƒ nat;

rule incr_nth â–¡ 0 â†ª 1 â¸¬ â–¡
with incr_nth â–¡ ($i +1) â†ª 0 â¸¬ incr_nth â–¡ $i
with incr_nth ($n â¸¬ $l) 0 â†ª $n +1 â¸¬ $l
with incr_nth ($n â¸¬ $l) ($i +1) â†ª $n â¸¬ incr_nth $l $i;

assert âŠ¢ incr_nth (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡) 1 â‰¡ 3 â¸¬ 3 â¸¬ 1 â¸¬ â–¡;
assert âŠ¢ incr_nth (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡) 2 â‰¡ 3 â¸¬ 2 â¸¬ 2 â¸¬ â–¡;
assert âŠ¢ incr_nth (3 â¸¬ 2 â¸¬ 1 â¸¬ â–¡) 5 â‰¡ 3 â¸¬ 2 â¸¬ 1 â¸¬ 0 â¸¬ 0 â¸¬ 1 â¸¬ â–¡;

// zip 

symbol zip [a b] : ğ•ƒ a â†’ ğ•ƒ b â†’ ğ•ƒ (a Ã— b);

rule zip â–¡ â–¡ â†ª â–¡
with zip â–¡ _ â†ª â–¡
with zip _ â–¡ â†ª â–¡
with zip ($x â¸¬ $l) ($y â¸¬ $m) â†ª $x & $y â¸¬ zip $l $m;

symbol unzip1 [a b] : ğ•ƒ (a Ã— b) â†’ ğ•ƒ a;

rule unzip1 â–¡  â†ª â–¡
with unzip1 ($x & _ â¸¬ $l) â†ª $x â¸¬ unzip1 $l;

symbol unzip2 [a b] : ğ•ƒ (a Ã— b) â†’ ğ•ƒ b;

rule unzip2 â–¡ â†ª â–¡
with unzip2 (_ & $y â¸¬ $l) â†ª $y â¸¬ unzip2 $l;

assert âŠ¢ unzip1 ((3 & 5) â¸¬ (6 & 4) â¸¬ (7 & 2) â¸¬ (8 & 1) â¸¬ â–¡) â‰¡ 3 â¸¬ 6 â¸¬ 7 â¸¬ 8 â¸¬ â–¡;
assert âŠ¢ unzip2 ((3 & 5) â¸¬ (6 & 4) â¸¬ (7 & 2) â¸¬ (8 & 1) â¸¬ â–¡) â‰¡ 5 â¸¬ 4 â¸¬ 2 â¸¬ 1 â¸¬ â–¡;

symbol all2 [a b] : (Ï„ a â†’ Ï„ b â†’ ğ”¹) â†’ ğ•ƒ a â†’ ğ•ƒ b â†’ ğ”¹;

rule all2 _ â–¡ â–¡ â†ª true
with all2 $p ($x â¸¬ $l) ($y â¸¬ $m) â†ª ($p $x $y) and (all2 $p $l $m);

opaque symbol unzip1_zip [a b] (la:ğ•ƒ a) (lb:ğ•ƒ b) :
  Ï€ (size la â‰¤ size lb) â†’ Ï€ (unzip1 (zip la lb) = la) â‰”
begin
  assume a b; induction
  { reflexivity; }
  { assume ea la h; induction
    { assume i; apply âŠ¥â‚‘ i; }
    { assume eb lb i j; apply feq (Î» l, ea â¸¬ l) (h lb j); }
  }
end;

opaque symbol unzip2_zip [a b] (la:ğ•ƒ a) (lb:ğ•ƒ b) :
  Ï€ (size lb â‰¤ size la) â†’ Ï€ (unzip2 (zip la lb) = lb) â‰”
begin
  assume a b; induction
  { assume lb h;
     have t:Ï€ (size lb = 0) { apply â‰¤0 (size lb) h; };
     symmetry; apply size0nil lb t; }
  { assume ea la h; induction
    { reflexivity; }
    { assume eb lb i j; apply feq (Î» l, eb â¸¬ l) (h lb j); }
  }
end;

opaque symbol size1_zip [a b] (la:ğ•ƒ a) (lb:ğ•ƒ b) :
  Ï€ (size la â‰¤ size lb) â†’ Ï€ (size (zip la lb) = size la) â‰”
begin
  assume a b; induction
  { reflexivity; }
  { assume ea la h; induction
    { assume i; apply âŠ¥â‚‘ i; }
    { assume eb lb i j; apply feq (+1) (h lb j); }
  }
end;

opaque symbol size2_zip [a b] (la:ğ•ƒ a) (lb:ğ•ƒ b) :
  Ï€ (size lb â‰¤ size la) â†’ Ï€ (size (zip la lb) = size lb) â‰”
begin
  assume a b; induction
  { assume lb h; symmetry; apply â‰¤0 (size lb) h; }
  { assume ea la h; induction
    { reflexivity; }
    { assume eb lb i j; apply feq (+1) (h lb j); }
  }
end;

opaque symbol size_zip [a b] (la:ğ•ƒ a) (lb:ğ•ƒ b) :
  Ï€ (size (zip la lb) = min (size la) (size lb)) â‰”
begin
  assume a b; induction
  { reflexivity }
  { assume ea la h; induction
    { reflexivity; }
    { assume eb lb i; simplify; apply feq (+1) (h lb); }
  }
end;

// double induction

opaque symbol seq_ind2 [a b] (p:ğ•ƒ a â†’ ğ•ƒ b â†’ Prop) :
  Ï€ (p â–¡ â–¡) â†’
  (Î  la lb ea eb, Ï€(size la = size lb) â†’ Ï€(p la lb) â†’ Ï€(p (ea â¸¬ la) (eb â¸¬ lb)))
  â†’ Î  la lb, Ï€(size la = size lb) â†’ Ï€(p la lb) â‰”
begin
  assume a b p p0 pH; induction
  { induction
    { assume h; apply p0; }
    { assume eb lb h1 h2; apply âŠ¥â‚‘; apply sâ‰ 0 [size lb]; symmetry; apply h2 }
  }
  { assume ea la h; induction
    { assume i; apply âŠ¥â‚‘ (sâ‰ 0 i); }
    { assume eb lb i j;
      have t:Ï€ (size la = size lb) { apply +1_inj j; };
      apply pH la lb ea eb t (h lb t); }
  }
end;

opaque symbol zip_cat [a b] (la sa:ğ•ƒ a) (lb sb:ğ•ƒ b) :
  Ï€ (size la = size lb) â†’ Ï€ (zip (la ++ sa) (lb ++ sb) = zip la lb ++ zip sa sb) â‰”
begin
  assume a b la sa lb sb h;
  apply @seq_ind2 a b (Î» l1 l2, (zip (l1 ++ sa) (l2 ++ sb) = zip l1 l2 ++ zip sa sb)) _ _ la lb h {
    reflexivity;
  } {
    assume l1 l2 e1 e2 h1 h2; simplify; apply feq (Î» l, e1 & e2 â¸¬ l) h2; 
  };
end;

opaque symbol nth_zip [a b] (x:Ï„ a) (y:Ï„ b) la lb i: Ï€(size la = size lb) â†’
  Ï€(nth (x & y) (zip la lb) i = nth x la i & nth y lb i) â‰”
begin
  assume a b x y; induction
  { assume lb i h;
    have t: Ï€ (lb = â–¡) { apply size0nil lb; symmetry; apply h; };
    rewrite t; reflexivity; }
  { assume ea la h; induction
    { assume i j; apply âŠ¥â‚‘ (sâ‰ 0 j); }
    { assume eb lb k; induction
      { assume m; reflexivity; }
      { assume i m n; refine h lb i _; apply +1_inj n; }
    }
  }
end;

opaque symbol rev_zip [a b] (la:ğ•ƒ a) (lb:ğ•ƒ b) :
  Ï€ (size la = size lb) â†’ Ï€ (rev (zip la lb) = zip (rev la) (rev lb)) â‰”
begin
  assume a b la lb h;
  apply seq_ind2 (Î» l1 l2, rev (zip l1 l2) = zip (rev l1) (rev l2)) _ _ la lb h {
    reflexivity;
  } {
    assume l1 l2 e1 e2 i j; simplify;
    have i': Ï€(size(rev l1) = size(rev l2))
      { rewrite @size_rev; rewrite @size_rev; apply i}; 
    rewrite zip_cat (rev l1) (e1 â¸¬ â–¡) (rev l2) (e2 â¸¬ â–¡) i';
    rewrite left j; reflexivity;
  };
end;
